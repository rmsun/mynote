Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-10-22T21:48:52+08:00

====== 网络字节顺序 ======
Created Saturday 22 October 2011

网络字节顺序
1、字节内的比特位不受这种顺序的影响
比如一个字节 1000 0000 （或表示为十六进制 80H)不管是什么顺序其内存中的表示法都是这样。
2、大于1个字节的数据类型才有字节顺序问题
比如 Byte A，这个变量只有一个字节的长度，所以根据上一条没有字节顺序问题。所以字节顺序是“字节之间的相对顺序”的意思。
3、大于1个字节的数据类型的字节顺序有两种
比如 short B，这是一个两字节的数据类型，这时就有字节之间的相对顺序问题了。
网络字节顺序是“所见即所得”的顺序。而Intel类型的CPU的字节顺序与此相反。
比如上面的 short B=0102H(十六进制，每两位表示一个字节的宽度）。所见到的是“0102”，按一般数学常识，数轴从左到右的方向增加，即内存地址从左到右增加的话，在内存中这个 short B的字节顺序是：
01 02
这就是网络字节顺序。所见到的顺序和在内存中的顺序是一致的！
而相反的字节顺序就不同了，其在内存中的顺序为：02 01
假设通过抓包得到网络数据的两个字节流为：01 02
如果这表示两个 Byte类型的变量，那么自然不需要考虑字节顺序的问题。
如果这表示一个 short 变量，那么就需要考虑字节顺序问题。根据网络字节顺序“所见即所得”的规则，这个变量的值就是：0102
假设本地主机是Intel类型的，那么要表示这个变量，有点麻烦：
定义变量 short X，
字节流地址为：pt，按顺序读取内存是为
x=*((short*)pt);
那么X的内存顺序当然是 01 02
按非“所见即所得”的规则，这个内存顺序和看到的一样显然是不对的，所以要把这两个字节的位置调换。
调换的方法可以自己定义，但用已经有的API还是更为方便。

网络字节顺序与主机字节顺序
NBO与HBO 网络字节顺序NBO（Network Byte Order）：按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。主机字节顺序（HBO，Host Byte Order）：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。Internet上数据以高位字节优先顺序在网络上传输，所以对于在内部是以低位字节优先方式存储数据的机器，在Internet上传输数据时就需要进行转换。 

htonl()
简述：
    将主机的无符号长整形数转换成网络字节顺序。
    #include <winsock.h>
    u_long PASCAL FAR htonl( u_long hostlong);
    hostlong：主机字节顺序表达的32位数。
注释：
    本函数将一个32位数从主机字节顺序转换成网络字节顺序。
返回值：
    htonl()返回一个网络字节顺序的值。

inet_ntoa()
简述：
将网络地址转换成“.”点隔的字符串格式。
#include <winsock.h>
char FAR* PASCAL FAR inet_ntoa( struct in_addr in);
in：一个表示Internet主机地址的结构。
注释：
本函数将一个用in参数所表示的Internet地址结构转换成以“.” 间隔的诸如“a.b.c.d”的字符串形式。请注意inet_ntoa()返回的字符串存放在WINDOWS套接口实现所分配的内存中。应用程序不应假设该内存是如何分配的。在同一个线程的下一个WINDOWS套接口调用前，数据将保证是有效。
返回值：
若无错误发生，inet_ntoa()返回一个字符指针。否则的话，返回NULL。其中的数据应在下一个WINDOWS套接口调用前复制出来。

网络中传输的数据有的和本地字节存储顺序一致，而有的则截然不同，为了数据的一致性，就要把本地的数据转换成网络上使用的格式，然后发送出去，接收的时候也是一样的，经过转换然后才去使用这些数据，基本的库函数中提供了这样的可以进行字节转换的函数，如和htons( ) htonl( ) ntohs( ) ntohl( )，这里n表示network，h表示host，htons( ) htonl( )用于本地字节向网络字节转换的场合，s表示short，即对2字节操作，l表示long即对4字节操作。同样ntohs( )ntohl( )用于网络字节向本地格式转换的场合。
