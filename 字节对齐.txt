Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-10-20T16:12:14+08:00

====== 字节对齐 ======
Created Thursday 20 October 2011

C编译器的缺省字节对齐方式（自然对界）
   在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。在结构中，编译器为结构的每个成员按其自然对界（alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储（成员之间可能有插入的空字节），第一个成员的地址和整个结构的地址相同。
C编译器缺省的结构成员自然对界条件为“N字节对齐”，N即该成员数据类型的长度。如int型成员的自然对界条件为4字节对齐，而double类型的结构成员的自然对界条件为8字节对齐。若该成员的起始偏移不位于该成员的“默认自然对界条件”上，则在前一个节面后面添加适当个数的空字节。
C编译器缺省的结构整体的自然对界条件为：该结构所有成员中要求的最大自然对界条件。若结构体各成员长度之和不为“结构整体自然对界条件的整数倍，则在最后一个成员后填充空字节。
例子（分析结构各成员的默认字节对界条界条件和结构整体的默认字节对界条件）:
struct Test
{
      char x1; // 成员x1为char型(其起始地址必须1字节对界)，其偏移地址为0
      char x2; // 成员x2为char型(其起始地址必须1字节对界，其偏移地址为1
      float x3; // 成员x3为float型(其起始地址必须4字节对界)，编译器在x2和x3之间填充了两个空字节，其偏移地址为4
      char x4; // 成员x4为char型(其起始地址必须1字节对界)，其偏移地址为8
};
因为Test结构体中，最大的成员为flaot x3，因些此结构体的自然对界条件为4字节对齐。则结构体长度就为12字节，内存布局为1100 1111 1000。
改变缺省的对界条件(指定对界)
· 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。
· 使用伪指令#pragma pack ()，取消自定义字节对齐方式。
     这时，对齐规则为：
l          数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 
l          结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 
l          结合1、2颗推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。
因此，当使用伪指令#pragma pack (2)时，Test结构体的大小为8，内存布局为11 11 11 10。
     需要注意一点，当结构体中包含一个子结构体时，子结构中的成员按照#pragma pack指定的数值和子结构最大数据成员长度中，比较小的那个进行进行对齐。例子如下：
#pragma pack(8)
struct s1{
short a;
long b;
};
 
struct s2{
char c;
s1 d;
long long e;
};
#pragma pack()
     sizeof(s2)的结果为24。S1的内存布局为1100 1111，S2的内存布局为1000 1100 1111 0000 1111 1111。
另外，还有如下的一种方式：
· __attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。
· __attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。
    以上的n = 1, 2, 4, 8, 16... 第一种方式较为常见。
